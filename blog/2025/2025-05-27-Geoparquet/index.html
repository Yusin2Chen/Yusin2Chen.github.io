<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h2 id="abstract">abstract</h2> <p>Efficiently discovering and preparing optimal geospatial datasets from heterogeneous, large-scale open repositories like Google Earth Engine (GEE), Microsoft Planetary Computer, NASA Earth Data, and AWS Open Data is a critical bottleneck for advanced geospatial analysis and AI applications. Open GeoAgent’s initial phase tackles this by implementing a robust system for discovering and preparing relevant geospatial data sources.</p> <p>This post details a two-stage architecture:</p> <ol> <li>A <strong>data processing pipeline</strong> converting STAC (SpatioTemporal Asset Catalog) metadata to GeoParquet, indexed by DuckDB for high-performance spatio-temporal querying.</li> <li>An <strong>intelligent retrieval layer</strong> using a multi-document Retrieval Augmented Generation (RAG) system built with LlamaIndex to identify task-specific collections and extract necessary parameters.</li> <li>scripts and geoparquet data link: https://huggingface.co/datasets/Yusin/GeoAgent-Geoparquet</li> </ol> <h2 id="part-1-high-performance-data-preparation-with-stac-geoparquet-and-duckdb">Part 1: High-Performance Data Preparation with STAC, GeoParquet, and DuckDB</h2> <p>The foundation of our data discovery pipeline is the standardized STAC metadata. To optimize for analytical queries, STAC Items from target collections across major open data providers are transformed into GeoParquet files.</p> <p><strong>1. STAC to GeoParquet Transformation:</strong></p> <ul> <li> <strong>Why GeoParquet?</strong> GeoParquet is an open, cloud-optimized, columnar format for geospatial vector data. Its columnar nature is key, allowing efficient storage and partial reads. This structure enables query engines like DuckDB to leverage predicate pushdown (filtering data at the source before reading it into memory) and columnar vectorization for significantly faster I/O and query processing. This is particularly advantageous compared to row-oriented formats or iterating through individual STAC items via an API for large-scale filtering.</li> <li> <strong>Organization</strong>: Typically, each set of GeoParquet files corresponds to STAC items from a specific data collection, maintaining a clear and organized data lake structure. The schema of the GeoParquet files is derived directly from the STAC Item structure, including common metadata fields, asset links, and the geometry.</li> </ul> <p><strong>2. DuckDB for Accelerated Indexing and Querying:</strong></p> <p>DuckDB, an in-memory OLAP (Online Analytical Processing) DBMS, is employed for its exceptional speed, ease of integration (especially its Python bindings and direct Parquet reading capabilities), and rich SQL dialect.</p> <p>Key DuckDB features utilized:</p> <ul> <li> <dl> <dt>Direct Parquet Querying</dt> <dd> <p>DuckDB can directly query one or more Parquet files, including those stored in cloud object storage.</p> </dd> </dl> <p>Python</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>import duckdb
conn = duckdb.connect()
conn.sql("SELECT count(id) FROM 'path/to/your/collection_geoparquet/*.parquet';")
</code></pre></div> </div> </li> <li> <dl> <dt>Spatial Extension</dt> <dd> <p>This extension is crucial for geospatial filtering. After installation (</p> </dd> </dl> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>INSTALL spatial; LOAD spatial;
</code></pre></div> </div> <p>), powerful spatial SQL operations can be performed.</p> <p>Python</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code># Example Python usage with DuckDB
import duckdb
  
# It's good practice to install and load extensions once per session if needed.
# For persistent storage, these might be set in the database configuration.
conn = duckdb.connect()
conn.execute("INSTALL spatial;")
conn.execute("LOAD spatial;")
  
# Define WKT for an Area of Interest (AOI) and time range
aoi_wkt = "POLYGON((-5.0 47.0, -5.0 48.0, -4.0 48.0, -4.0 47.0, -5.0 47.0))" # Example polygon
start_time = "2023-03-01T00:00:00Z"
end_time = "2023-08-31T23:59:59Z"
  
query = f"""
SELECT id, properties_datetime, assets_B04_href, properties_eo_cloud_cover
FROM read_parquet('path_to_your_geoparquet_files/*.parquet', union_by_name=True)
WHERE "sar:product_type" = 'GRD' -- Example for Sentinel-1
  AND "sar:instrument_mode" = 'IW' -- Example for Sentinel-1
  AND ST_Intersects(geometry, ST_GeomFromText('{aoi_wkt}'))
  AND properties_datetime &gt;= '{start_time}'
  AND properties_datetime &lt;= '{end_time}'
  AND properties_eo_cloud_cover &lt; 20; -- Example cloud cover filter
"""
result = conn.execute(query).fetchdf()
print(result.head())
</code></pre></div> </div> </li> <li> <dl> <dt>CQL2 to SQL Translation</dt> <dd> <p>To maintain compatibility with existing STAC API workflows and allow users to leverage familiar query languages, the pygeofilter library, along with its library, along with its pygeofilter-duckdb backend, can parse CQL2-JSON filters and translate them into DuckDB SQL WHERE clauses. This allows users to define filters once and apply them to both STAC APIs and the GeoParquet/DuckDB backend.</p> </dd> </dl> <p>Python</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code># Conceptual Python usage with pygeofilter
from pygeofilter.parsers.cql2_json import parse as json_parse
from pygeofilter.backends.duckdb import to_sql_where
from pygeofilter.util import IdempotentDict
  
cql2_filter = {
  "op": "and",
  "args": [
    {"op": "between", "args": [{"property": "eo:cloud_cover"}, 0, 21]},
    {"op": "between", "args": [{"property": "datetime"}, "2023-02-01T00:00:00Z", "2023-02-28T23:59:59Z"]},
    {"op": "s_intersects", "args": [{"property": "geometry"}, {"type": "Polygon", "coordinates": [[[...]]]}]}
  ]
}
# field_mapping can be used if property names differ from GeoParquet column names
sql_where_clause = to_sql_where(json_parse(cql2_filter), IdempotentDict())
# full_query = f"SELECT * FROM read_parquet('{geoparquet_path}') WHERE {sql_where_clause}"
</code></pre></div> </div> </li> </ul> <p>This spatio-temporal pre-filtering significantly prunes the search space, making the subsequent semantic retrieval step more focused and computationally feasible.</p> <h2 id="part-2-intelligent-collection-selection-via-multi-document-rag-with-llamaindex">Part 2: Intelligent Collection Selection via Multi-Document RAG with LlamaIndex</h2> <p>Even after spatio-temporal filtering, multiple data collections might meet the basic criteria. Selecting the <em>most suitable</em> collection for a nuanced task (e.g., “which LiDAR dataset is best for sub-meter vertical accuracy canopy height models in a temperate forest region?”) requires deeper semantic understanding of each collection’s specifications, processing levels, and suitability for specific applications. A Multi-Document Retrieval Augmented Generation (RAG) system, built using LlamaIndex, provides this capability.</p> <p><strong>1. Architecture Overview:</strong></p> <p>The system employs a two-tiered agent structure:</p> <ul> <li> <strong>Collection-Specific Agents (<code class="language-plaintext highlighter-rouge">FunctionAgent</code>)</strong>: Each candidate geospatial data collection, represented by its detailed metadata, user guides, scientific papers describing it, or even API documentation, is managed by a dedicated LlamaIndex <code class="language-plaintext highlighter-rouge">FunctionAgent</code>.</li> <li> <strong>Top-Level Orchestrator Agent (<code class="language-plaintext highlighter-rouge">FunctionAgent</code> or <code class="language-plaintext highlighter-rouge">ReActAgent</code>)</strong>: This agent receives the user’s primary query and intelligently routes sub-queries to the appropriate collection-specific agents.</li> </ul> <p><strong>2. Building Collection-Specific Agents:</strong></p> <p>The process, inspired by LlamaIndex’s multi-document agent patterns, involves creating specialized agents for each data collection:</p> <ul> <li> <p><strong>Document Processing</strong>: For each collection, relevant documents (e.g., landing pages, technical specifications, usage tutorials) are loaded and parsed into nodes using <code class="language-plaintext highlighter-rouge">SentenceSplitter</code>.</p> </li> <li> <p>Index Creation</p> <p>:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">VectorStoreIndex</code>: Built from these nodes using an embedding model (e.g., <code class="language-plaintext highlighter-rouge">OpenAIEmbedding(model="text-embedding-3-small")</code>). This index allows for semantic search within the collection’s documentation (e.g., “find information about radiometric correction”).</li> <li> <code class="language-plaintext highlighter-rouge">SummaryIndex</code>: Optionally, a <code class="language-plaintext highlighter-rouge">SummaryIndex</code> can be built to generate concise summaries of each document/collection. This is useful for providing quick overviews to the top-level agent or the user.</li> </ul> </li> <li> <p>Query Engines and Tools</p> <p>:</p> <ul> <li>The indices are exposed as query engines (e.g., <code class="language-plaintext highlighter-rouge">vector_index.as_query_engine()</code>, <code class="language-plaintext highlighter-rouge">summary_index.as_query_engine()</code>).</li> <li>These query engines are then wrapped into <code class="language-plaintext highlighter-rouge">QueryEngineTool</code> instances. Each tool is given a name and a description that outlines its specific capabilities (e.g., “Useful for answering specific factual questions about Collection X’s processing levels”).</li> </ul> </li> <li> <p><strong>Agent Definition</strong>: A <code class="language-plaintext highlighter-rouge">FunctionAgent</code> (often powered by an LLM like OpenAI’s <code class="language-plaintext highlighter-rouge">gpt-4o</code>) is instantiated for each collection. It’s equipped with the tools created above and a system prompt that directs it to use these tools to answer questions <em>exclusively</em> about its assigned data collection, avoiding reliance on prior knowledge. An asynchronous function <code class="language-plaintext highlighter-rouge">build_agent_per_doc</code> typically encapsulates this logic.</p> </li> </ul> <p><strong>3. Top-Level Orchestrator Agent:</strong></p> <ul> <li> <p><strong>Tool Aggregation</strong>: The specialized collection agents are exposed as tools to the top-level agent. This is done by wrapping the <code class="language-plaintext highlighter-rouge">agent.run</code> (or <code class="language-plaintext highlighter-rouge">agent.arun</code> for async) method of each collection agent into a <code class="language-plaintext highlighter-rouge">FunctionTool</code> using <code class="language-plaintext highlighter-rouge">FunctionTool.from_defaults</code>. The <code class="language-plaintext highlighter-rouge">description</code> of each <code class="language-plaintext highlighter-rouge">FunctionTool</code> is critical; it’s often derived from a summary of the collection the agent represents, enabling the top-level agent to make informed decisions about which tool (i.e., which collection agent) to engage for a given query.</p> </li> <li> <p>Tool Retrieval and Reranking</p> <p>:</p> <ol> <li>An <code class="language-plaintext highlighter-rouge">ObjectIndex.from_objects(all_tools, index_cls=VectorStoreIndex)</code> is created to index all the collection-agent tools.</li> <li>When the top-level agent receives a query, an initial set of relevant tools (collection agents) is retrieved using <code class="language-plaintext highlighter-rouge">obj_index.as_node_retriever(similarity_top_k=N)</code>.</li> <li>This retrieved set can be further refined using a postprocessor like <code class="language-plaintext highlighter-rouge">CohereRerank(top_n=M, model="rerank-english-v3.0")</code> (or similar) to improve the precision of tool selection.</li> <li>A <code class="language-plaintext highlighter-rouge">CustomObjectRetriever</code> (as demonstrated in LlamaIndex examples) can be implemented. This custom retriever can not only fetch the top N tools post-reranking but also dynamically inject a “comparison” or “query planning” sub-agent/tool. This sub-agent would take the original query and the selected tools as input, enabling it to explicitly compare information from multiple collections if the user’s query requires it (e.g., “Compare Sentinel-2 and Landsat 9 for vegetation monitoring”).</li> </ol> </li> <li> <p><strong>Query Execution</strong>: The top-level agent (e.g., a <code class="language-plaintext highlighter-rouge">FunctionAgent</code> or <code class="language-plaintext highlighter-rouge">ReActAgent</code> with an LLM like <code class="language-plaintext highlighter-rouge">gpt-4o</code>) then utilizes these selected and reranked tools (i.e., collection agents) to synthesize an answer to the user’s query. It effectively delegates sub-questions or information gathering tasks to the most relevant collection specialists.</p> </li> </ul> <p><strong>4. Output:</strong></p> <p>The system aims to identify the most suitable collection(s) for the user’s task. Furthermore, it can be prompted to extract key parameters (e.g., specific band names, asset keys for direct access, relevant processing levels, or even Python code snippets for data loading) based on the context retrieved by the RAG pipeline.</p> <p>Okay, I’ve revised the blog post to be more technical and included instructions for the flowchart.</p> <hr> <h2 id="the-first-step-of-open-geoagent-a-technical-dive-into-finding-useful-geospatial-data-sources">The First Step of Open GeoAgent: A Technical Dive into Finding Useful Geospatial Data Sources</h2> <p>Efficiently discovering and preparing optimal geospatial datasets from heterogeneous, large-scale open repositories like Google Earth Engine (GEE), Microsoft Planetary Computer, NASA Earth Data, and AWS Open Data is a critical bottleneck for advanced geospatial analysis and AI applications. Open GeoAgent’s initial phase tackles this by implementing a robust system for discovering and preparing relevant geospatial data sources.</p> <p>This post details a two-stage architecture:</p> <ol> <li>A <strong>data processing pipeline</strong> converting STAC (SpatioTemporal Asset Catalog) metadata to GeoParquet, indexed by DuckDB for high-performance spatio-temporal querying.</li> <li>An <strong>intelligent retrieval layer</strong> using a multi-document Retrieval Augmented Generation (RAG) system built with LlamaIndex to identify task-specific collections and extract necessary parameters.</li> </ol> <h3 id="part-1-high-performance-data-preparation-with-stac-geoparquet-and-duckdb-1">Part 1: High-Performance Data Preparation with STAC, GeoParquet, and DuckDB</h3> <p>The foundation of our data discovery pipeline is the standardized STAC metadata. To optimize for analytical queries, STAC Items from target collections across major open data providers are transformed into GeoParquet files.</p> <p><strong>1. STAC to GeoParquet Transformation:</strong></p> <ul> <li> <strong>Why GeoParquet?</strong> GeoParquet is an open, cloud-optimized, columnar format for geospatial vector data. Its columnar nature is key, allowing efficient storage and partial reads. This structure enables query engines like DuckDB to leverage predicate pushdown (filtering data at the source before reading it into memory) and columnar vectorization for significantly faster I/O and query processing. This is particularly advantageous compared to row-oriented formats or iterating through individual STAC items via an API for large-scale filtering.</li> <li> <strong>Organization</strong>: Typically, each set of GeoParquet files corresponds to STAC items from a specific data collection, maintaining a clear and organized data lake structure. The schema of the GeoParquet files is derived directly from the STAC Item structure, including common metadata fields, asset links, and the geometry.</li> </ul> <p><strong>2. DuckDB for Accelerated Indexing and Querying:</strong></p> <p>DuckDB, an in-memory OLAP (Online Analytical Processing) DBMS, is employed for its exceptional speed, ease of integration (especially its Python bindings and direct Parquet reading capabilities), and rich SQL dialect.</p> <p>Key DuckDB features utilized:</p> <ul> <li> <dl> <dt>Direct Parquet Querying</dt> <dd> <p>DuckDB can directly query one or more Parquet files, including those stored in cloud object storage.</p> </dd> </dl> <p>Python</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>import duckdb
conn = duckdb.connect()
conn.sql("SELECT count(id) FROM 'path/to/your/collection_geoparquet/*.parquet';")
</code></pre></div> </div> </li> <li> <dl> <dt>Spatial Extension</dt> <dd> <p>This extension is crucial for geospatial filtering. After installation (</p> </dd> </dl> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>INSTALL spatial; LOAD spatial;
</code></pre></div> </div> <p>), powerful spatial SQL operations can be performed.</p> <p>Python</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code># Example Python usage with DuckDB
import duckdb
  
# It's good practice to install and load extensions once per session if needed.
# For persistent storage, these might be set in the database configuration.
conn = duckdb.connect()
conn.execute("INSTALL spatial;")
conn.execute("LOAD spatial;")
  
# Define WKT for an Area of Interest (AOI) and time range
aoi_wkt = "POLYGON((-5.0 47.0, -5.0 48.0, -4.0 48.0, -4.0 47.0, -5.0 47.0))" # Example polygon
start_time = "2023-03-01T00:00:00Z"
end_time = "2023-08-31T23:59:59Z"
  
query = f"""
SELECT id, properties_datetime, assets_B04_href, properties_eo_cloud_cover
FROM read_parquet('path_to_your_geoparquet_files/*.parquet', union_by_name=True)
WHERE "sar:product_type" = 'GRD' -- Example for Sentinel-1
  AND "sar:instrument_mode" = 'IW' -- Example for Sentinel-1
  AND ST_Intersects(geometry, ST_GeomFromText('{aoi_wkt}'))
  AND properties_datetime &gt;= '{start_time}'
  AND properties_datetime &lt;= '{end_time}'
  AND properties_eo_cloud_cover &lt; 20; -- Example cloud cover filter
"""
result = conn.execute(query).fetchdf()
print(result.head())
</code></pre></div> </div> </li> <li> <dl> <dt>CQL2 to SQL Translation</dt> <dd> <p>To maintain compatibility with existing STAC API workflows and allow users to leverage familiar query languages, the</p> </dd> </dl> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>pygeofilter
</code></pre></div> </div> <p>library, along with its</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>pygeofilter-duckdb
</code></pre></div> </div> <p>backend, can parse CQL2-JSON filters and translate them into DuckDB SQL</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>WHERE
</code></pre></div> </div> <p>clauses. This allows users to define filters once and apply them to both STAC APIs and the GeoParquet/DuckDB backend.</p> <p>Python</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code># Conceptual Python usage with pygeofilter
from pygeofilter.parsers.cql2_json import parse as json_parse
from pygeofilter.backends.duckdb import to_sql_where
from pygeofilter.util import IdempotentDict
  
cql2_filter = {
  "op": "and",
  "args": [
    {"op": "between", "args": [{"property": "eo:cloud_cover"}, 0, 21]},
    {"op": "between", "args": [{"property": "datetime"}, "2023-02-01T00:00:00Z", "2023-02-28T23:59:59Z"]},
    {"op": "s_intersects", "args": [{"property": "geometry"}, {"type": "Polygon", "coordinates": [[[...]]]}]}
  ]
}
# field_mapping can be used if property names differ from GeoParquet column names
sql_where_clause = to_sql_where(json_parse(cql2_filter), IdempotentDict())
# full_query = f"SELECT * FROM read_parquet('{geoparquet_path}') WHERE {sql_where_clause}"
</code></pre></div> </div> </li> <li> <dl> <dt>STAC Item Reconstruction</dt> <dd> <p>Query results from DuckDB (often retrieved as Arrow tables or Pandas DataFrames) can be efficiently converted back to</p> </dd> </dl> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>pystac.Item
</code></pre></div> </div> <p>objects using the</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>stac_geoparquet.arrow._api.stac_table_to_items
</code></pre></div> </div> <p>function. This ensures seamless integration with downstream STAC-aware tools and libraries.</p> <p>Python</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code># Conceptual Python snippet (based on your provided material)
# import json
# import pystac
# from stac_geoparquet.arrow._api import stac_table_to_items
# db_result_arrow_table = conn.execute(full_query).fetch_arrow_table()
# stac_items = []
# for item_dict in stac_table_to_items(db_result_arrow_table):
#     item_dict['assets'] = json.loads(item_dict['assets']) # Assets might be stored as JSON strings
#     stac_items.append(pystac.Item.from_dict(item_dict))
</code></pre></div> </div> </li> </ul> <p>This spatio-temporal pre-filtering significantly prunes the search space, making the subsequent semantic retrieval step more focused and computationally feasible.</p> <h3 id="part-2-intelligent-collection-selection-via-multi-document-rag-with-llamaindex-1">Part 2: Intelligent Collection Selection via Multi-Document RAG with LlamaIndex</h3> <p>Even after spatio-temporal filtering, multiple data collections might meet the basic criteria. Selecting the <em>most suitable</em> collection for a nuanced task (e.g., “which LiDAR dataset is best for sub-meter vertical accuracy canopy height models in a temperate forest region?”) requires deeper semantic understanding of each collection’s specifications, processing levels, and suitability for specific applications. A Multi-Document Retrieval Augmented Generation (RAG) system, built using LlamaIndex, provides this capability.</p> <p><strong>1. Architecture Overview:</strong></p> <p>The system employs a two-tiered agent structure:</p> <ul> <li> <strong>Collection-Specific Agents (<code class="language-plaintext highlighter-rouge">FunctionAgent</code>)</strong>: Each candidate geospatial data collection, represented by its detailed metadata, user guides, scientific papers describing it, or even API documentation, is managed by a dedicated LlamaIndex <code class="language-plaintext highlighter-rouge">FunctionAgent</code>.</li> <li> <strong>Top-Level Orchestrator Agent (<code class="language-plaintext highlighter-rouge">FunctionAgent</code> or <code class="language-plaintext highlighter-rouge">ReActAgent</code>)</strong>: This agent receives the user’s primary query and intelligently routes sub-queries to the appropriate collection-specific agents.</li> </ul> <p><strong>2. Building Collection-Specific Agents:</strong></p> <p>The process, inspired by LlamaIndex’s multi-document agent patterns, involves creating specialized agents for each data collection:</p> <ul> <li> <p><strong>Document Processing</strong>: For each collection, relevant documents (e.g., landing pages, technical specifications, usage tutorials) are loaded and parsed into nodes using <code class="language-plaintext highlighter-rouge">SentenceSplitter</code>.</p> </li> <li> <p>Index Creation</p> <p>:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">VectorStoreIndex</code>: Built from these nodes using an embedding model (e.g., <code class="language-plaintext highlighter-rouge">OpenAIEmbedding(model="text-embedding-3-small")</code>). This index allows for semantic search within the collection’s documentation (e.g., “find information about radiometric correction”).</li> <li> <code class="language-plaintext highlighter-rouge">SummaryIndex</code>: Optionally, a <code class="language-plaintext highlighter-rouge">SummaryIndex</code> can be built to generate concise summaries of each document/collection. This is useful for providing quick overviews to the top-level agent or the user.</li> </ul> </li> <li> <p>Query Engines and Tools</p> <p>:</p> <ul> <li>The indices are exposed as query engines (e.g., <code class="language-plaintext highlighter-rouge">vector_index.as_query_engine()</code>, <code class="language-plaintext highlighter-rouge">summary_index.as_query_engine()</code>).</li> <li>These query engines are then wrapped into <code class="language-plaintext highlighter-rouge">QueryEngineTool</code> instances. Each tool is given a name and a description that outlines its specific capabilities (e.g., “Useful for answering specific factual questions about Collection X’s processing levels”).</li> </ul> </li> <li> <p><strong>Agent Definition</strong>: A <code class="language-plaintext highlighter-rouge">FunctionAgent</code> (often powered by an LLM like OpenAI’s <code class="language-plaintext highlighter-rouge">gpt-4o</code>) is instantiated for each collection. It’s equipped with the tools created above and a system prompt that directs it to use these tools to answer questions <em>exclusively</em> about its assigned data collection, avoiding reliance on prior knowledge. An asynchronous function <code class="language-plaintext highlighter-rouge">build_agent_per_doc</code> typically encapsulates this logic.</p> </li> </ul> <p><strong>3. Top-Level Orchestrator Agent:</strong></p> <ul> <li> <p><strong>Tool Aggregation</strong>: The specialized collection agents are exposed as tools to the top-level agent. This is done by wrapping the <code class="language-plaintext highlighter-rouge">agent.run</code> (or <code class="language-plaintext highlighter-rouge">agent.arun</code> for async) method of each collection agent into a <code class="language-plaintext highlighter-rouge">FunctionTool</code> using <code class="language-plaintext highlighter-rouge">FunctionTool.from_defaults</code>. The <code class="language-plaintext highlighter-rouge">description</code> of each <code class="language-plaintext highlighter-rouge">FunctionTool</code> is critical; it’s often derived from a summary of the collection the agent represents, enabling the top-level agent to make informed decisions about which tool (i.e., which collection agent) to engage for a given query.</p> </li> <li> <p>Tool Retrieval and Reranking</p> <p>:</p> <ol> <li>An <code class="language-plaintext highlighter-rouge">ObjectIndex.from_objects(all_tools, index_cls=VectorStoreIndex)</code> is created to index all the collection-agent tools.</li> <li>When the top-level agent receives a query, an initial set of relevant tools (collection agents) is retrieved using <code class="language-plaintext highlighter-rouge">obj_index.as_node_retriever(similarity_top_k=N)</code>.</li> <li>This retrieved set can be further refined using a postprocessor like <code class="language-plaintext highlighter-rouge">CohereRerank(top_n=M, model="rerank-english-v3.0")</code> (or similar) to improve the precision of tool selection.</li> <li>A <code class="language-plaintext highlighter-rouge">CustomObjectRetriever</code> (as demonstrated in LlamaIndex examples) can be implemented. This custom retriever can not only fetch the top N tools post-reranking but also dynamically inject a “comparison” or “query planning” sub-agent/tool. This sub-agent would take the original query and the selected tools as input, enabling it to explicitly compare information from multiple collections if the user’s query requires it (e.g., “Compare Sentinel-2 and Landsat 9 for vegetation monitoring”).</li> </ol> </li> <li> <p><strong>Query Execution</strong>: The top-level agent (e.g., a <code class="language-plaintext highlighter-rouge">FunctionAgent</code> or <code class="language-plaintext highlighter-rouge">ReActAgent</code> with an LLM like <code class="language-plaintext highlighter-rouge">gpt-4o</code>) then utilizes these selected and reranked tools (i.e., collection agents) to synthesize an answer to the user’s query. It effectively delegates sub-questions or information gathering tasks to the most relevant collection specialists.</p> </li> </ul> <p><strong>4. Output:</strong></p> <p>The system aims to identify the most suitable collection(s) for the user’s task. Furthermore, it can be prompted to extract key parameters (e.g., specific band names, asset keys for direct access, relevant processing levels, or even Python code snippets for data loading) based on the context retrieved by the RAG pipeline.</p> <h3 id="conclusion-and-future-work">Conclusion and Future Work</h3> <p>This two-stage architecture – combining high-performance pre-filtering with DuckDB/GeoParquet and sophisticated semantic retrieval with LlamaIndex RAG – forms a robust and technically sound first step for Open GeoAgent. It addresses the dual challenges of massive data volume and the need for nuanced semantic relevance in data discovery, paving the way for more automated, intelligent, and insightful geospatial data utilization. Future enhancements will focus on loading data from queried data collection to local data analysis.</p> </body></html>